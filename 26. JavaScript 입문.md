## 28장. JavaScript에서 비동기 처리

### 0. JavaScript란?
> - 웹 브라우저에서 사용하기 위하여 만들어진 프로그래민 언어
> - 웹 브라우저 상에서 UI를 동적으로 보여주기 위해 사용
> - NodeJs를 통해 서버단에서도 JS를 사용하여 API 개발
> - Electron framework를 사용하여 Desktop App 개발
> - React Native, NativeScript framework를 사용하여 mobile App 개발

### 1. 브라우저에서 JavaScript 사용
> - 크롬 브라우저에서 개발자 도구에서 JS 사용
> - 코드샌드박스( https://codesandbox.io/ )를 통해 JS 사용

### 2. 변수와 상수
> #### 변수
> - 바뀔 수 있는 값
> - let을 사용하여 변수 선언
> - 한번 선언하면 같은 이름으로 다시 선언할 수 없음

> #### 상수
> - 바꿀 수 없는 고정적인 값
> - const를 사용하여 상수 선언
> - 한번 선언하면 같은 이름으로 다시 선언할 수 없음

> #### 데이터 타입
```javascript
  let value = 1;              // 숫자
  let text = "string";        // 문자열
  let isValue = false;        // boolean
  let friend = null;          // null ( 값이 없음 )
  let criminal = undifined;   // undifined ( 정의되지 않음 )
```

### 3. 연산자 - 산술연산자, 대입연산자, 증감연산자
> #### 산술연산자
> - +, -, *, /, %

> #### 대입연산자
> - =, +=, -=, *=, /=, %=

> #### 증감연산자
> - ++, --
> - x++, x-- : 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가, 감소시킴
> - ++x, --x : 먼저 피연산자의 값을 1 증가, 감소시킨 후에 해당 연산을 진행

### 4. 연산자 - 논리연산자
> - NOT : !
> - AND : &&
> - OR  : ||
> - 논리연산자 우선순위 : NOT -> AND -> OR
```javascript
  const a = !false;
  const b = true && false;
  const c = true || false;
  
  const value = !( true && false || true && false || !false )
  // !( true && false || true && false || true )
  // !( false || false || true )
  // !( true )
  // false
```

### 5. 연산자 - 비교연산자, 문자열 붙이기
> #### 비교연산자
> - ===, !==, <, >, <=, >=, ==, !=
> - ==, != 는 타입을 비교하지 않기 때문에 사용하지 않는 것을 권장

> #### 문자열 붙이기
> - + 연산자를 사용하여 문자열 붙이기
```javascript
  const a = "푸른";
  const b = "하늘";
  
  console.log( a + b )
```

### 6. 조건문 - if, else, else if
> #### if
> - 특정 조건이 만족될 경우 if의 블록( { } ) 안에 코드 실행
```javascript
  const a = 1;
  if (a + 1 === 2) {
    const a = 2;
    console.log("if문 안의 a : ", a);
    // 2 출력
  }
  console.log("if문 밖의 a : ", a);
// 1 출력
```
> #### else
> - 특정 조건이 만족되지 않은 경우 else의 블록( { } ) 안에 코드 실행
```javascript
  const a = 10;
  if (a > 15) {
    console.log("a가 15보다 크다");
  } else {
    console.log("a가 15보다 크지 않다");
  }
  // "a가 15보다 크지 않다" 출력
```
> #### else if
> - 특정 조건을 여러개 사용
```javascript
  const a = 10;

  if (a === 5) {
    console.log("a는 5");
  } else if (a === 7) {
    console.log("a는 7");
  } else if (a === 10) {
    console.log("a는 10");
  } else {
    console.log("a는 5, 7, 10이 아님");
  }
```

### 7. 조건문 - switch case
> - 특정 값이 무엇이냐에 따라 다른 작업을 실행하기 쉽게 할 수 있음
```javascript
  const device = "iphone";

  switch (device) {
    case "iphone":
      console.log("아이폰");
      break;
    case "ipad":
      console.log("아이폰");
      break;
    default:
      console.log("모름");
      break;
  }
```

### 8. 함수
> - 특정 코드를 하나의 명령으로 실행할 수 있게 해주는 기능
```javascript
  function add(a, b) {
    return a + b;
  }
  
  const sum = add(1, 2);
  console.log(sum);
  // 3 출력
```

### 9. 함수 - Template Literal
> - ES6에 도입된 새로운 문자열 표기법
> - 백틱( backtick ) 문자 `를 사용
> - 여러 줄에 걸쳐 문자열을 작성할 수 있으며 템플릿 리터럴 내의 모든 white-space는 있는 그대로 적용됨
> - 문자열 인터폴레이션 사용가능
> > - 새로운 문자열을 삽입할 수 있는 기능
> > - ${ ... }
```javascript
  const first = "Gildong";
  const last = "Hong";

  console.log(`My Name is ${first} ${last}.`);
  // My Name is Gildong Hong. 출력
```
> > - 문자열 인터폴레이션 내의 표현식은 문자열로 강제 타입 변환됨
```javascript
  console.log(`1 + 1 = ${1 + 1}`); 
  // "1 + 1 = 2"
```
> #### ES6
> - JavaScript 버전으로 ECNAScript 6, ES2015로 불림

### 10. 함수 - 연습
```javascript
  function getGrade(score) {
    if (score === 100) {
      return "A+";
    } else if (score >= 90) {
      return "A";
    } else if (score === 89) {
      return "B+";
    } else if (score >= 80) {
      return "B";
    } else if (score === 79) {
      return "C+";
    } else if (score >= 70) {
      return "C";
    } else if (score === 69) {
      return "D+";
    } else if (score >= 60) {
      return "D";
    } else {
      return "F";
    }
  };

  const grade = getGrade(90);
  console.log(grade);
```

### 11. 함수 - 화살표 함수
> - function 키워드 대신에 => 문자를 사용해서 함수 구현
```javascript
  const add = (a, b) => {
    return a + b;
  };

  console.log(add(1, 2));
```
> - 코드 단축
```javascript
  const add = (a, b) => a + b;

  console.log(add(1, 2));
```

### 12. 객체
> - key에 해당하는 부분은 공백이 없어야함, 만약 공백이 있어야 하는 상황이면 따옴표( '' )로 감싸서 문자열을 사용
```javascript
  const sample = {
    'key with space': true
  };
```

> #### 함수의 파라미터로 객체를 받아 사용
```javascript
  const ironMan = {
    name: '토니 스타크',
    actor: '로버트 다우니 주니어',
    alias: '아이언맨'
  };

  const captainAmerica = {
    name: '스티븐 로저스',
    actor: '크리스 에반스',
    alias: '캡틴 아메리카'
  };

  const print = (hero) => {
    const text = `${hero.alias}(${hero.name}) 역할을 맡은 배우는 ${
      hero.actor
    }.`;
    console.log(text);
  }

  print(ironMan);
  print(captainAmerica);
```

### 13. 객체 - 비구조화 할당
> #### 객체 구조 분해
```javascript  
  const ironMan = {
    name: '토니 스타크',
    actor: '로버트 다우니 주니어',
    alias: '아이언맨'
  };

  const captainAmerica = {
    name: '스티븐 로저스',
    actor: '크리스 에반스',
    alias: '캡틴 아메리카'
  };
  
  const print = ({ alias, name, actor }) => {
  // const print = (hero) => {
    // const { alias, name, actor } = hero;
    const text = `${alias}(${name}) 역할을 맡은 배우는 ${actor} 입니다.`;
    console.log(text);
  }

  print(ironMan);
  print(captainAmerica);
```

### 14. 객체 - 객체 안에 함수 넣기
> #### this
```javascript 
  const dog = {
    name: "댕댕이",
    sound: "멍멍",
    // say: function say() {
    // say: function() {
    say() {
      console.log(this.sound);
      // 여기서 this는 dog 객체를 가리킴
    }
  };

  dog.say();
```

> - 화살표함수로 선언하면 this 사용 못함
> > - function으로 선언한 함수는 this 가 제대로 자신이 속한 객체를 가르키게 되는데, 화살표 함수는 그렇지 않기 때문
```javascript 
  const dog = {
    name: "댕댕이",
    sound: "멍멍",
    say: ()=> {
      console.log(this.sound);
      // TypeError: Cannot read property 'sound' of undefined
    }
  };

  dog.say();
```

```javascript 
  const dog = {
    name: "댕댕이",
    sound: "멍멍",
    say() {
      console.log(this.sound);
    }
  };

  const cat = {
    name : "야옹이",
    sound :"야옹"
  }

  dog.say();

  // cat에 등록된 say()의 this는 자신이 속한 객체 cat을 가리킴
  cat.say = dog.say
  cat.say()
  // 야옹 출력
  
  // 함수를 밖으로 꺼내면 this랑 관계가 끊어짐
  const catSay = cat.say
  catSay()
  // TypeError: Cannot read property 'sound' of undefined
```

### 15. 객체 - Getter와 Setter 함수
> - 특정 값을 바꾸려고 하거나, 특정 값을 조회하여고 할 때 원하는 코드를 실행시킬 수 있음
> #### Getter
> > - getter 함수는 호출( sum() )이 아니라 조회( sum ), 특정 값을 조회하여 할 때 함수를 실행시켜 값을 반환 함
> > - getter 함수 설정 시 함수명 앞에 get 키워드를 사용하고 return 값이 반드시 있어야함
```javascript 
  const numbers = {
    a: 1,
    b: 2,
    get sum() {
      console.log("sum 함수가 실행");
      return this.a + this.b;
    }
  };

  console.log(numbers.sum);
```

> #### Setter
> > - setter 함수는 호출( sum() )이 아니라 조회( sum ), 특정 값을 조회하여 할 때 함수를 실행시켜 값을 반환 함
> > - setter 함수 설정 시 함수명 앞에 set 키워드를 사용하고 파라미터 값이 반드시 있어야함
```javascript 
  const dog = {
    _name : "댕댕이",
    set name(value){
      console.log("이름 변경", value)
      this._name = value
    }
  }

  console.log(dog._name)
  // 댕댕이 출력
  dog.name = "멍멍이"
  // 이름 변경 멍멍이 출력
  console.log(dog._name)
  // 멍멍이 출력
```

> > - getter, setter 함수 같이 사용
```javascript 
  const dog = {
    _name: "댕댕이",
    get name() {
      console.log("_name을 조회");
      return this._name;
    },
    set name(value) {
      console.log("이름 변경", value);
      this._name = value;
    }
  };

  console.log(dog.name);
  // _name을 조회
  // 댕댕이
  dog.name = "멍멍이";
  // 이름 변경 멍멍이
  console.log(dog.name);
  // _name을 조회
  // 멍멍이
```
####  Getter와 Setter 함수 사용 이유
> - 캡슐화 ( encapsulation )
> > 1. 유사한 기능이나 변수를 한 집합으로 하여 더 관리하기 쉽게하고 코드를 명확히 함.

> > 2. 외부에서 멤버를 엑세스하는 방법을 지정할 수 있도록, 직접 접근을 막거나 접근 전 부가적인 처리를 요구함.

> > 3. 정보를 외부에 은닉하여 외부에서는 해당 집합의 세부 내용에 집중하지 않도록 함

참조 : <https://ko.javascript.info/property-accessors>





















